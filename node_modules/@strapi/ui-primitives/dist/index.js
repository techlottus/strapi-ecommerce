import { jsx as d, jsxs as Ne, Fragment as Ae } from "react/jsx-runtime";
import * as r from "react";
import { composeEventHandlers as T } from "@radix-ui/primitive";
import { useComposedRefs as _ } from "@radix-ui/react-compose-refs";
import { createContextScope as Qe, createContext as et } from "@radix-ui/react-context";
import { DismissableLayer as tt } from "@radix-ui/react-dismissable-layer";
import { useFocusGuards as ot } from "@radix-ui/react-focus-guards";
import { FocusScope as nt } from "@radix-ui/react-focus-scope";
import { useId as ne } from "@radix-ui/react-id";
import * as le from "@radix-ui/react-popper";
import { createPopperScope as rt } from "@radix-ui/react-popper";
import { Portal as lt } from "@radix-ui/react-portal";
import { Primitive as N } from "@radix-ui/react-primitive";
import { useControllableState as ie } from "@radix-ui/react-use-controllable-state";
import { useLayoutEffect as H } from "@radix-ui/react-use-layout-effect";
import { hideOthers as st } from "aria-hidden";
import * as _e from "react-dom";
import { RemoveScroll as ct } from "react-remove-scroll";
import { Slot as Ie } from "@radix-ui/react-slot";
import { clamp as Ze } from "@radix-ui/number";
import { createCollection as Rt } from "@radix-ui/react-collection";
import { useDirection as Nt } from "@radix-ui/react-direction";
import { useCallbackRef as At } from "@radix-ui/react-use-callback-ref";
import { useCallbackRef as Rn } from "@radix-ui/react-use-callback-ref";
import { usePrevious as _t } from "@radix-ui/react-use-previous";
import { VisuallyHidden as Mt } from "@radix-ui/react-visually-hidden";
let ye = /* @__PURE__ */ new Map();
function Ot(n, s) {
  let e = n + (s ? Object.entries(s).sort((o, l) => o[0] < l[0] ? -1 : 1).join() : "");
  if (ye.has(e))
    return ye.get(e);
  let t = new Intl.Collator(n, s);
  return ye.set(e, t), t;
}
function Me(n, s) {
  let e = Ot(n, {
    usage: "search",
    ...s
  });
  return {
    startsWith(t, o) {
      return o.length === 0 ? !0 : (t = t.normalize("NFC"), o = o.normalize("NFC"), e.compare(t.slice(0, o.length), o) === 0);
    },
    endsWith(t, o) {
      return o.length === 0 ? !0 : (t = t.normalize("NFC"), o = o.normalize("NFC"), e.compare(t.slice(-o.length), o) === 0);
    },
    contains(t, o) {
      if (o.length === 0)
        return !0;
      t = t.normalize("NFC"), o = o.normalize("NFC");
      let l = 0, i = o.length;
      for (; l + i <= t.length; l++) {
        let c = t.slice(l, l + i);
        if (e.compare(o, c) === 0)
          return !0;
      }
      return !1;
    }
  };
}
const Dt = (n) => {
  const s = r.useRef();
  return r.useEffect(() => {
    s.current = n;
  }), s.current;
};
function kt(n) {
  const s = `${n}CollectionProvider`, [e, t] = Qe(s), [o, l] = e(s, {
    collectionRef: { current: null },
    itemMap: /* @__PURE__ */ new Map(),
    listeners: /* @__PURE__ */ new Set()
  }), i = (u) => {
    const { scope: m, children: S } = u, x = r.useRef(null), C = r.useRef(/* @__PURE__ */ new Map()).current, h = r.useRef(/* @__PURE__ */ new Set()).current;
    return /* @__PURE__ */ d(o, { scope: m, itemMap: C, collectionRef: x, listeners: h, children: S });
  };
  i.displayName = s;
  const c = `${n}CollectionSlot`, a = r.forwardRef((u, m) => {
    const { scope: S, children: x } = u, C = l(c, S), h = _(m, C.collectionRef);
    return /* @__PURE__ */ d(Ie, { ref: h, children: x });
  });
  a.displayName = c;
  const g = `${n}CollectionItemSlot`, f = "data-radix-collection-item", v = r.forwardRef((u, m) => {
    const { scope: S, children: x, ...C } = u, h = r.useRef(null), w = _(m, h), A = l(g, S);
    return r.useEffect(() => {
      const V = Array.from(A.itemMap.values());
      return A.itemMap.set(h, { ref: h, ...C }), A.listeners.forEach((M) => M(Array.from(A.itemMap.values()), V)), () => {
        const M = Array.from(A.itemMap.values());
        A.itemMap.delete(h), A.listeners.forEach((E) => E(Array.from(A.itemMap.values()), M));
      };
    }), /* @__PURE__ */ d(Ie, { [f]: "", ref: w, children: x });
  });
  v.displayName = g;
  function p(u) {
    const m = l(`${n}CollectionConsumer`, u), S = r.useCallback(() => {
      const C = m.collectionRef.current;
      if (!C)
        return [];
      const h = Array.from(C.querySelectorAll(`[${f}]`));
      return Array.from(m.itemMap.values()).sort(
        (V, M) => h.indexOf(V.ref.current) - h.indexOf(M.ref.current)
      );
    }, [m.collectionRef, m.itemMap]), x = r.useCallback(
      (C) => (m.listeners.add(C), () => m.listeners.delete(C)),
      [m.listeners]
    );
    return { getItems: S, subscribe: x };
  }
  return [
    { Provider: i, Slot: a, ItemSlot: v },
    p,
    t
  ];
}
const Ft = [" ", "Enter", "ArrowUp", "ArrowDown"], Lt = ["Enter"], Je = (n) => !!(n.length === 1 && n.match(/\S| /)), it = "Combobox", [pe, xe] = kt(it), [Bt, Y] = et(it), Ht = ({ children: n }) => /* @__PURE__ */ d(le.Root, { children: /* @__PURE__ */ d(pe.Provider, { scope: void 0, children: n }) }), $t = (n) => {
  const {
    allowCustomValue: s = !1,
    autocomplete: e = "none",
    children: t,
    open: o,
    defaultOpen: l,
    onOpenChange: i,
    value: c,
    defaultValue: a,
    onValueChange: g,
    disabled: f,
    required: v = !1,
    locale: p = "en-EN",
    onTextValueChange: u,
    textValue: m,
    defaultTextValue: S,
    filterValue: x,
    defaultFilterValue: C,
    onFilterValueChange: h
  } = n, [w, A] = r.useState(null), [V, M] = r.useState(null), [E, k] = r.useState(null), [$, G] = r.useState(null), [F = !1, O] = ie({
    prop: o,
    defaultProp: l,
    onChange: i
  }), [L, B] = ie({
    prop: c,
    defaultProp: a,
    onChange: g
  }), [U, K] = ie({
    prop: m,
    defaultProp: S,
    onChange: u
  }), [X, Z] = ie({
    prop: x,
    defaultProp: C,
    onChange: h
  }), W = ne(), ue = r.useCallback(
    (z, se) => {
      const de = se.map((y) => y.ref.current), [J, ...ce] = de, [ee] = ce.slice(-1), b = $;
      for (const y of z) {
        if (y === b)
          return;
        if (y?.scrollIntoView({ block: "nearest" }), y === J && V && (V.scrollTop = 0), y === ee && V && (V.scrollTop = V.scrollHeight), G(y), e === "both") {
          const D = se.find((I) => I.ref.current === y);
          D && K(D.textValue);
        }
        if (y !== b)
          return;
      }
    },
    [e, K, V, $]
  );
  return r.useEffect(() => {
    e !== "both" && G(null);
  }, [U, e]), r.useEffect(() => {
    if (E && w)
      return st([E, w]);
  }, [E, w]), /* @__PURE__ */ d(Ht, { children: /* @__PURE__ */ d(
    Bt,
    {
      allowCustomValue: s,
      autocomplete: e,
      required: v,
      trigger: w,
      onTriggerChange: A,
      contentId: W,
      value: L,
      onValueChange: B,
      open: F,
      onOpenChange: O,
      disabled: f,
      locale: p,
      focusFirst: ue,
      textValue: U,
      onTextValueChange: K,
      onViewportChange: M,
      onContentChange: k,
      visuallyFocussedItem: $,
      filterValue: X,
      onFilterValueChange: Z,
      onVisuallyFocussedItemChange: G,
      children: /* @__PURE__ */ d(
        nt,
        {
          trapped: F,
          onMountAutoFocus: (z) => {
            z.preventDefault();
          },
          onUnmountAutoFocus: (z) => {
            w?.focus({ preventScroll: !0 }), document.getSelection()?.empty(), z.preventDefault();
          },
          children: t
        }
      )
    }
  ) });
}, Ut = "ComboboxTrigger", Kt = r.forwardRef((n, s) => {
  const { ...e } = n, t = Y(Ut);
  return /* @__PURE__ */ d(le.Anchor, { asChild: !0, children: /* @__PURE__ */ d("div", { ref: s, "data-disabled": t.disabled ? "" : void 0, ...e }) });
}), at = "ComboboxInput", Wt = r.forwardRef((n, s) => {
  const e = Y(at), t = r.useRef(null), { getItems: o } = xe(void 0), { startsWith: l } = Me(e.locale, { sensitivity: "base" }), i = e.disabled, c = _(t, s, e.onTriggerChange), a = () => {
    i || e.onOpenChange(!0);
  }, g = Dt(e.filterValue);
  return H(() => {
    const f = setTimeout(() => {
      if (e.textValue === "" || e.textValue === void 0 || e.filterValue === "" || e.filterValue === void 0)
        return;
      const v = o().find(
        (u) => u.type === "option" && l(u.textValue, e.textValue)
      ), p = vo(g ?? "", e.filterValue);
      v && !e.visuallyFocussedItem && p === e.filterValue.length && t.current.setSelectionRange(e.filterValue.length, e.textValue.length);
    });
    return () => clearTimeout(f);
  }, [e.textValue, e.filterValue, l, e.visuallyFocussedItem, o, g]), /* @__PURE__ */ d(
    "input",
    {
      type: "text",
      role: "combobox",
      "aria-controls": e.contentId,
      "aria-expanded": e.open,
      "aria-required": e.required,
      "aria-autocomplete": e.autocomplete,
      "data-state": e.open ? "open" : "closed",
      "aria-disabled": i,
      "aria-activedescendant": e.visuallyFocussedItem?.id,
      disabled: i,
      "data-disabled": i ? "" : void 0,
      "data-placeholder": e.textValue === void 0 ? "" : void 0,
      value: e.textValue ?? "",
      ...n,
      ref: c,
      onClick: T(n.onClick, (f) => {
        f.currentTarget.focus();
      }),
      onPointerDown: T(n.onPointerDown, (f) => {
        f.button === 0 && f.ctrlKey === !1 && (a(), f.currentTarget.focus());
      }),
      onKeyDown: T(n.onKeyDown, (f) => {
        if (["ArrowUp", "ArrowDown", "Home", "End"].includes(f.key))
          setTimeout(() => {
            let p = o().filter((u) => !u.disabled).map((u) => u.ref.current);
            if (["ArrowUp", "End"].includes(f.key) && (p = p.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(f.key)) {
              const u = e.visuallyFocussedItem ?? f.target;
              let m = p.indexOf(u);
              m === p.length - 1 && (m = -1), p = p.slice(m + 1);
            }
            if (["ArrowDown"].includes(f.key) && e.autocomplete === "both" && p.length > 1) {
              const [u, ...m] = p, S = o().find((x) => x.ref.current === u).textValue;
              e.textValue === S && (p = m);
            }
            e.focusFirst(p, o());
          }), f.preventDefault();
        else if (["Escape"].includes(f.key))
          e.open ? e.onOpenChange(!1) : (e.onValueChange(void 0), e.onTextValueChange("")), f.preventDefault();
        else if (Lt.includes(f.key)) {
          if (e.visuallyFocussedItem) {
            const v = o().find((p) => p.ref.current === e.visuallyFocussedItem);
            v && (e.onValueChange(v.value), e.onTextValueChange(v.textValue), e.autocomplete === "both" && e.onFilterValueChange(v.textValue), v.ref.current?.click());
          } else {
            const v = o().find(
              (p) => p.type === "option" && !p.disabled && p.textValue === e.textValue
            );
            v && (e.onValueChange(v.value), e.onTextValueChange(v.textValue), e.autocomplete === "both" && e.onFilterValueChange(v.textValue), v.ref.current?.click());
          }
          e.onOpenChange(!1), f.preventDefault();
        } else
          e.onVisuallyFocussedItemChange(null);
      }),
      onChange: T(n.onChange, (f) => {
        e.onTextValueChange(f.currentTarget.value), e.autocomplete === "both" && e.onFilterValueChange(f.currentTarget.value);
      }),
      onKeyUp: T(n.onKeyUp, (f) => {
        !e.open && (Je(f.key) || ["ArrowUp", "ArrowDown", "Home", "End", "Backspace"].includes(f.key)) && a(), setTimeout(() => {
          if (e.autocomplete === "both" && Je(f.key) && e.filterValue !== void 0) {
            const v = e.filterValue, p = o().find((u) => l(u.textValue, v));
            p && e.onTextValueChange(p.textValue);
          }
        });
      }),
      onBlur: T(n.onBlur, () => {
        e.onVisuallyFocussedItemChange(null);
        const [f] = o().filter(
          (p) => p.textValue === e.textValue && p.type === "option"
        );
        if (e.allowCustomValue) {
          f && (e.onValueChange(f.value), e.autocomplete === "both" && e.onFilterValueChange(f.textValue));
          return;
        }
        const [v] = o().filter((p) => p.value === e.value && p.type === "option");
        f ? e.onValueChange(f.value) : v && e.textValue !== "" ? (e.onTextValueChange(v.textValue), e.autocomplete === "both" && e.onFilterValueChange(v.textValue)) : (e.onValueChange(void 0), e.onTextValueChange(""));
      })
    }
  );
}), zt = r.forwardRef((n, s) => {
  const { children: e, ...t } = n, o = Y(at), l = o.disabled, i = () => {
    l || (o.onOpenChange(!0), o.trigger?.focus());
  };
  return /* @__PURE__ */ d(
    N.button,
    {
      "aria-hidden": !0,
      type: "button",
      "aria-disabled": l,
      "aria-controls": o.contentId,
      "aria-expanded": o.open,
      disabled: l,
      "data-disabled": l ? "" : void 0,
      ...t,
      tabIndex: -1,
      ref: s,
      onClick: T(t.onClick, () => {
        o.trigger?.focus();
      }),
      onPointerDown: T(t.onPointerDown, (c) => {
        c.button === 0 && c.ctrlKey === !1 && (i(), c.preventDefault());
      }),
      onKeyDown: T(t.onKeyDown, (c) => {
        Ft.includes(c.key) && (i(), c.preventDefault());
      }),
      children: e || "▼"
    }
  );
}), Gt = "ComboboxPortal", ut = (n) => /* @__PURE__ */ d(lt, { asChild: !0, ...n });
ut.displayName = Gt;
const dt = "ComboboxContent", jt = r.forwardRef((n, s) => {
  const e = Y(dt), [t, o] = r.useState();
  if (H(() => {
    o(new DocumentFragment());
  }, []), !e.open) {
    const l = t;
    return l ? _e.createPortal(
      /* @__PURE__ */ d(pe.Slot, { scope: void 0, children: /* @__PURE__ */ d("div", { children: n.children }) }),
      l
    ) : null;
  }
  return /* @__PURE__ */ d(qt, { ...n, ref: s });
}), Yt = 10, qt = r.forwardRef(
  (n, s) => {
    const { onEscapeKeyDown: e, onPointerDownOutside: t, ...o } = n, l = Y(dt), i = _(s, (a) => l.onContentChange(a)), { onOpenChange: c } = l;
    return ot(), r.useEffect(() => {
      const a = () => {
        c(!1);
      };
      return window.addEventListener("blur", a), window.addEventListener("resize", a), () => {
        window.removeEventListener("blur", a), window.removeEventListener("resize", a);
      };
    }, [c]), /* @__PURE__ */ d(ct, { allowPinchZoom: !0, children: /* @__PURE__ */ d(
      tt,
      {
        asChild: !0,
        onEscapeKeyDown: e,
        onPointerDownOutside: t,
        onFocusOutside: (a) => {
          a.preventDefault();
        },
        onDismiss: () => {
          l.onOpenChange(!1), l.trigger?.focus({ preventScroll: !0 });
        },
        children: /* @__PURE__ */ d(
          Xt,
          {
            role: "listbox",
            id: l.contentId,
            "data-state": l.open ? "open" : "closed",
            onContextMenu: (a) => a.preventDefault(),
            ...o,
            ref: i,
            style: {
              // flex layout so we can place the scroll buttons properly
              display: "flex",
              flexDirection: "column",
              // reset the outline by default as the content MAY get focused
              outline: "none",
              ...o.style
            }
          }
        )
      }
    ) });
  }
), Xt = r.forwardRef(
  (n, s) => {
    const { align: e = "start", collisionPadding: t = Yt, ...o } = n;
    return /* @__PURE__ */ d(
      le.Content,
      {
        ...o,
        ref: s,
        align: e,
        collisionPadding: t,
        style: {
          // Ensure border-box for floating-ui calculations
          boxSizing: "border-box",
          ...o.style,
          "--radix-combobox-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-combobox-content-available-width": "var(--radix-popper-available-width)",
          "--radix-combobox-content-available-height": "var(--radix-popper-available-height)",
          "--radix-combobox-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-combobox-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
), Zt = "ComboboxViewport", Jt = r.forwardRef((n, s) => {
  const e = Y(Zt), t = _(s, e.onViewportChange);
  return /* @__PURE__ */ Ne(Ae, { children: [
    /* @__PURE__ */ d(
      "style",
      {
        dangerouslySetInnerHTML: {
          __html: "[data-radix-combobox-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-combobox-viewport]::-webkit-scrollbar{display:none}"
        }
      }
    ),
    /* @__PURE__ */ d(pe.Slot, { scope: void 0, children: /* @__PURE__ */ d(
      N.div,
      {
        "data-radix-combobox-viewport": "",
        role: "presentation",
        ...n,
        ref: t,
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto",
          ...n.style
        }
      }
    ) })
  ] });
}), ft = "ComboboxItem", [Qt, pt] = et(ft), mt = r.forwardRef((n, s) => {
  const { value: e, disabled: t = !1, textValue: o, ...l } = n, i = r.useRef(null), c = _(s, i), { getItems: a } = xe(void 0), {
    onTextValueChange: g,
    textValue: f,
    visuallyFocussedItem: v,
    ...p
  } = Y(ft), u = ne(), [m, S] = r.useState(o ?? ""), x = r.useMemo(() => v === a().find((M) => M.ref.current === i.current)?.ref.current, [a, v]), C = p.value === e, h = () => {
    t || (p.onValueChange(e), g(m), p.onOpenChange(!1), p.autocomplete === "both" && p.onFilterValueChange(m), p.trigger?.focus({ preventScroll: !0 }));
  }, { startsWith: w } = Me(p.locale, { sensitivity: "base" }), A = r.useCallback((M) => {
    S((E) => E || (M?.textContent ?? "").trim());
  }, []);
  r.useEffect(() => {
    C && f === void 0 && m !== "" && g(m);
  }, [m, C, f, g]);
  const V = ne();
  return p.autocomplete === "list" && m && f && !w(m, f) || p.autocomplete === "both" && m && p.filterValue && !w(m, p.filterValue) ? null : /* @__PURE__ */ d(Qt, { textId: u, onTextValueChange: A, isSelected: C, children: /* @__PURE__ */ d(pe.ItemSlot, { scope: void 0, value: e, textValue: m, disabled: t, type: "option", children: /* @__PURE__ */ d(
    N.div,
    {
      role: "option",
      "aria-labelledby": u,
      "data-highlighted": x ? "" : void 0,
      "aria-selected": C && x,
      "data-state": C ? "checked" : "unchecked",
      "aria-disabled": t || void 0,
      "data-disabled": t ? "" : void 0,
      tabIndex: t ? void 0 : -1,
      ...l,
      id: V,
      ref: c,
      onPointerUp: T(l.onPointerUp, h)
    }
  ) }) });
}), eo = "ComboboxItemText", to = r.forwardRef((n, s) => {
  const { className: e, style: t, ...o } = n, l = pt(eo), i = _(s, l.onTextValueChange);
  return /* @__PURE__ */ d(N.span, { id: l.textId, ...o, ref: i });
}), oo = "ComboboxItemIndicator", no = r.forwardRef((n, s) => {
  const { isSelected: e } = pt(oo);
  return e ? /* @__PURE__ */ d(N.span, { "aria-hidden": !0, ...n, ref: s }) : null;
}), ht = "ComboboxNoValueFound", ro = r.forwardRef((n, s) => {
  const { textValue: e = "", locale: t } = Y(ht), [o, l] = r.useState([]), { subscribe: i } = xe(void 0), { startsWith: c } = Me(t, { sensitivity: "base" });
  return r.useEffect(() => {
    const a = i((g) => {
      l(g);
    });
    return () => {
      a();
    };
  }, [i]), o.some((a) => c(a.textValue, e)) ? null : /* @__PURE__ */ d(N.div, { ...n, ref: s });
}), lo = r.forwardRef((n, s) => {
  const { disabled: e = !1, ...t } = n, o = Y(ht), { textValue: l, visuallyFocussedItem: i } = o, { getItems: c, subscribe: a } = xe(void 0), g = r.useRef(null), [f, v] = r.useState(!1), p = _(s, g), u = r.useMemo(() => i === c().find((x) => x.ref.current === g.current)?.ref.current, [c, i]), m = ne(), S = () => {
    !e && l && (o.onValueChange(l), o.onTextValueChange(l), o.onOpenChange(!1), o.autocomplete === "both" && o.onFilterValueChange(l), o.trigger?.focus({ preventScroll: !0 }));
  };
  return H(() => {
    const x = a((C) => {
      v(!C.some((h) => h.textValue === l && h.type !== "create"));
    });
    return c().length === 0 && v(!0), () => {
      x();
    };
  }, [l, a, c]), !l || !f ? null : /* @__PURE__ */ d(
    pe.ItemSlot,
    {
      scope: void 0,
      value: l ?? "",
      textValue: l ?? "",
      disabled: e,
      type: "create",
      children: /* @__PURE__ */ d(
        N.div,
        {
          role: "option",
          tabIndex: e ? void 0 : -1,
          "aria-disabled": e || void 0,
          "data-disabled": e ? "" : void 0,
          "data-highlighted": u ? "" : void 0,
          ...t,
          id: m,
          ref: p,
          onPointerUp: T(t.onPointerUp, S)
        }
      )
    }
  );
}), so = $t, co = Kt, io = Wt, ao = zt, uo = ut, fo = jt, po = Jt, mo = mt, ho = to, go = no, xo = ro, Co = lo;
function vo(n, s) {
  const e = Math.min(n.length, s.length);
  for (let t = 0; t < e; t++)
    if (n[t] !== s[t])
      return t;
  return e;
}
const Tn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ComboboxItem: mt,
  Content: fo,
  CreateItem: Co,
  Icon: ao,
  Item: mo,
  ItemIndicator: go,
  ItemText: ho,
  NoValueFound: xo,
  Portal: uo,
  Root: so,
  TextInput: io,
  Trigger: co,
  Viewport: po
}, Symbol.toStringTag, { value: "Module" })), So = [" ", "Enter", "ArrowUp", "ArrowDown"], bo = [" ", "Enter"], me = "Select", [Ce, he, wo] = Rt(me), [ae, yo] = Qe(me, [
  wo,
  rt
]), ve = rt(), [Io, q] = ae(me), [To, Vo] = ae(me), Oe = (n) => {
  const {
    __scopeSelect: s,
    children: e,
    open: t,
    defaultOpen: o,
    onOpenChange: l,
    value: i,
    defaultValue: c,
    onValueChange: a,
    dir: g,
    // name,
    // autoComplete,
    disabled: f,
    required: v,
    multi: p = !1
  } = n, u = ve(s), [m, S] = r.useState(null), [x, C] = r.useState(null), [h, w] = r.useState(!1), A = Nt(g), [V = !1, M] = ie({
    prop: t,
    defaultProp: o,
    onChange: l
  }), [E, k] = ie({
    prop: i,
    defaultProp: c,
    onChange(O) {
      a && (Array.isArray(O), a(O));
    }
  }), $ = r.useRef(null), [G, F] = r.useState(/* @__PURE__ */ new Set());
  return /* @__PURE__ */ d(le.Root, { ...u, children: /* @__PURE__ */ d(
    Io,
    {
      required: v,
      scope: s,
      trigger: m,
      onTriggerChange: S,
      valueNode: x,
      onValueNodeChange: C,
      valueNodeHasChildren: h,
      onValueNodeHasChildrenChange: w,
      contentId: ne(),
      value: E,
      onValueChange: k,
      open: V,
      onOpenChange: M,
      dir: A,
      triggerPointerDownPosRef: $,
      disabled: f,
      multi: p,
      children: /* @__PURE__ */ d(Ce.Provider, { scope: s, children: /* @__PURE__ */ d(
        To,
        {
          scope: n.__scopeSelect,
          onNativeOptionAdd: r.useCallback((O) => {
            F((L) => new Set(L).add(O));
          }, []),
          onNativeOptionRemove: r.useCallback((O) => {
            F((L) => {
              const B = new Set(L);
              return B.delete(O), B;
            });
          }, []),
          children: e
        }
      ) })
    }
  ) });
};
Oe.displayName = me;
const gt = "SelectTrigger", De = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, ...t } = n, o = ve(e), l = q(gt, e), i = l.disabled, c = _(s, l.onTriggerChange), a = he(e), [g, f, v] = Vt((u) => {
      const m = a().filter((C) => !C.disabled), S = m.find((C) => C.value === l.value), x = Et(m, u, S);
      if (x !== void 0 && !Array.isArray(x.value)) {
        const C = l.multi ? [x.value] : x.value;
        l.onValueChange(C);
      }
    }), p = () => {
      i || (l.onOpenChange(!0), v());
    };
    return /* @__PURE__ */ d(le.Anchor, { asChild: !0, ...o, children: /* @__PURE__ */ d(
      N.div,
      {
        role: "combobox",
        "aria-controls": l.contentId,
        "aria-expanded": l.open,
        "aria-required": l.required,
        "aria-autocomplete": "none",
        dir: l.dir,
        "data-state": l.open ? "open" : "closed",
        "data-disabled": i ? "" : void 0,
        "data-placeholder": l.value === void 0 ? "" : void 0,
        tabIndex: i ? void 0 : 0,
        ...t,
        ref: c,
        onClick: T(t.onClick, (u) => {
          u.currentTarget.focus();
        }),
        onPointerDown: T(t.onPointerDown, (u) => {
          const m = u.target;
          m.hasPointerCapture(u.pointerId) && m.releasePointerCapture(u.pointerId), (m.closest("button") ?? m.closest("div")) === u.currentTarget && u.button === 0 && u.ctrlKey === !1 && (p(), l.triggerPointerDownPosRef.current = {
            x: Math.round(u.pageX),
            y: Math.round(u.pageY)
          }, u.preventDefault());
        }),
        onKeyDown: T(t.onKeyDown, (u) => {
          const m = g.current !== "", S = u.ctrlKey || u.altKey || u.metaKey, x = u.target;
          (x.closest("button") ?? x.closest("div")) === u.currentTarget && (!S && u.key.length === 1 && f(u.key), !(m && u.key === " ") && So.includes(u.key) && (p(), u.preventDefault()));
        })
      }
    ) });
  }
);
De.displayName = gt;
const xt = "SelectValue", ke = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, children: t, placeholder: o, ...l } = n, i = q(xt, e), { onValueNodeHasChildrenChange: c } = i, a = t !== void 0, g = _(s, i.onValueNodeChange), [f, v] = r.useState([]), p = he(e);
    H(() => {
      c(a);
    }, [c, a]), r.useLayoutEffect(() => {
      if (Array.isArray(i.value) && f.length !== i.value.length) {
        const m = setTimeout(() => {
          const S = p().filter(
            (x) => Array.isArray(x.value) ? !1 : i.value?.includes(x.value)
          );
          v(S);
        });
        return () => {
          clearTimeout(m);
        };
      }
    }, [i.value, p, f]);
    let u;
    if ((i.value === void 0 || i.value.length === 0) && o !== void 0)
      u = /* @__PURE__ */ d("span", { children: o });
    else if (typeof t == "function")
      if (Array.isArray(i.value)) {
        const m = i.value.map((S) => {
          const x = f.find((C) => C.value === S);
          return x ? t({ value: S, textValue: x?.textValue }) : null;
        });
        u = m.every((S) => S === null) ? o : m;
      } else
        u = t(i.value);
    else
      u = t;
    return /* @__PURE__ */ d(N.span, { ...l, ref: g, children: u || null });
  }
);
ke.displayName = xt;
const Eo = "SelectIcon", Fe = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, children: t, ...o } = n;
    return /* @__PURE__ */ d(N.span, { "aria-hidden": !0, ...o, ref: s, children: t || "▼" });
  }
);
Fe.displayName = Eo;
const Po = "SelectPortal", Le = (n) => /* @__PURE__ */ d(lt, { asChild: !0, ...n });
Le.displayName = Po;
const re = "SelectContent", Be = r.forwardRef(
  (n, s) => {
    const e = q(re, n.__scopeSelect), [t, o] = r.useState();
    if (H(() => {
      o(new DocumentFragment());
    }, []), !e.open) {
      const l = t;
      return l ? _e.createPortal(
        /* @__PURE__ */ d(Ct, { scope: n.__scopeSelect, children: /* @__PURE__ */ d(Ce.Slot, { scope: n.__scopeSelect, children: /* @__PURE__ */ d("div", { children: n.children }) }) }),
        l
      ) : null;
    }
    return /* @__PURE__ */ d(vt, { ...n, ref: s });
  }
);
Be.displayName = re;
const j = 10, [Ct, Q] = ae(re), Ro = "SelectContentImpl", vt = r.forwardRef(
  (n, s) => {
    const {
      __scopeSelect: e,
      position: t = "item-aligned",
      onCloseAutoFocus: o,
      onEscapeKeyDown: l,
      onPointerDownOutside: i,
      //
      // PopperContent props
      side: c,
      sideOffset: a,
      align: g,
      alignOffset: f,
      arrowPadding: v,
      collisionBoundary: p,
      collisionPadding: u,
      sticky: m,
      hideWhenDetached: S,
      avoidCollisions: x,
      //
      ...C
    } = n, h = q(re, e), [w, A] = r.useState(null), [V, M] = r.useState(null), E = _(s, (b) => A(b)), [k, $] = r.useState(null), [G, F] = r.useState(null), O = he(e), [L, B] = r.useState(!1), U = r.useRef(!1);
    r.useEffect(() => {
      if (w)
        return st(w);
    }, [w]), ot();
    const K = r.useCallback(
      (b) => {
        const [y, ...D] = O().map((R) => R.ref.current), [I] = D.slice(-1), P = document.activeElement;
        for (const R of b)
          if (R === P || (R?.scrollIntoView({ block: "nearest" }), R === y && V && (V.scrollTop = 0), R === I && V && (V.scrollTop = V.scrollHeight), R?.focus(), document.activeElement !== P))
            return;
      },
      [O, V]
    ), X = r.useCallback(
      () => K([k, w]),
      [K, k, w]
    );
    r.useEffect(() => {
      L && X();
    }, [L, X]);
    const { onOpenChange: Z, triggerPointerDownPosRef: W } = h;
    r.useEffect(() => {
      if (w) {
        let b = { x: 0, y: 0 };
        const y = (I) => {
          b = {
            x: Math.abs(Math.round(I.pageX) - (W.current?.x ?? 0)),
            y: Math.abs(Math.round(I.pageY) - (W.current?.y ?? 0))
          };
        }, D = (I) => {
          b.x <= 10 && b.y <= 10 ? I.preventDefault() : w.contains(I.target) || Z(!1), document.removeEventListener("pointermove", y), W.current = null;
        };
        return W.current !== null && (document.addEventListener("pointermove", y), document.addEventListener("pointerup", D, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", y), document.removeEventListener("pointerup", D, { capture: !0 });
        };
      }
    }, [w, Z, W]), r.useEffect(() => {
      const b = () => Z(!1);
      return window.addEventListener("blur", b), window.addEventListener("resize", b), () => {
        window.removeEventListener("blur", b), window.removeEventListener("resize", b);
      };
    }, [Z]);
    const [ue, z] = Vt((b) => {
      const y = O().filter((P) => !P.disabled), D = y.find((P) => P.ref.current === document.activeElement), I = Et(y, b, D);
      I && setTimeout(() => I.ref.current.focus());
    }), se = r.useCallback(
      (b, y, D) => {
        const I = !U.current && !D;
        (h.value !== void 0 && h.value === y || I) && ($(b), I && (U.current = !0));
      },
      [h.value]
    ), de = r.useCallback(() => w?.focus(), [w]), J = r.useCallback(
      (b, y, D) => {
        const I = !U.current && !D;
        (h.value !== void 0 && (Array.isArray(y) ? y.every((R) => h.value?.includes(R)) : h.value === y) || I) && F(b);
      },
      [h.value]
    ), ce = t === "popper" ? Te : St, ee = ce === Te ? {
      side: c,
      sideOffset: a,
      align: g,
      alignOffset: f,
      arrowPadding: v,
      collisionBoundary: p,
      collisionPadding: u,
      sticky: m,
      hideWhenDetached: S,
      avoidCollisions: x
    } : {};
    return /* @__PURE__ */ d(
      Ct,
      {
        scope: e,
        content: w,
        viewport: V,
        onViewportChange: M,
        itemRefCallback: se,
        selectedItem: k,
        onItemLeave: de,
        itemTextRefCallback: J,
        focusSelectedItem: X,
        selectedItemText: G,
        position: t,
        isPositioned: L,
        searchRef: ue,
        children: /* @__PURE__ */ d(ct, { as: Ie, allowPinchZoom: !0, children: /* @__PURE__ */ d(
          nt,
          {
            asChild: !0,
            trapped: h.open,
            onMountAutoFocus: (b) => {
              b.preventDefault();
            },
            onUnmountAutoFocus: T(o, (b) => {
              h.trigger?.focus({ preventScroll: !0 }), document.getSelection()?.empty(), b.preventDefault();
            }),
            children: /* @__PURE__ */ d(
              tt,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: l,
                onPointerDownOutside: i,
                onFocusOutside: (b) => b.preventDefault(),
                onDismiss: () => h.onOpenChange(!1),
                children: /* @__PURE__ */ d(
                  ce,
                  {
                    role: "listbox",
                    id: h.contentId,
                    "data-state": h.open ? "open" : "closed",
                    "aria-multiselectable": h.multi ? "true" : void 0,
                    dir: h.dir,
                    onContextMenu: (b) => b.preventDefault(),
                    ...C,
                    ...ee,
                    onPlaced: () => B(!0),
                    ref: E,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...C.style
                    },
                    onKeyDown: T(C.onKeyDown, (b) => {
                      const y = b.ctrlKey || b.altKey || b.metaKey;
                      if (b.key === "Tab" && b.preventDefault(), !y && b.key.length === 1 && z(b.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(b.key)) {
                        let I = O().filter((P) => !P.disabled).map((P) => P.ref.current);
                        if (["ArrowUp", "End"].includes(b.key) && (I = I.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(b.key)) {
                          const P = b.target, R = I.indexOf(P);
                          I = I.slice(R + 1);
                        }
                        setTimeout(() => K(I)), b.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
vt.displayName = Ro;
const No = "SelectItemAlignedPosition", St = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, onPlaced: t, ...o } = n, l = q(re, e), i = Q(re, e), [c, a] = r.useState(null), [g, f] = r.useState(null), v = _(s, (E) => f(E)), p = he(e), u = r.useRef(!1), m = r.useRef(!0), { viewport: S, selectedItem: x, selectedItemText: C, focusSelectedItem: h } = i, w = r.useCallback(() => {
      if (l.trigger && l.valueNode && c && g && S && x && C) {
        const E = l.trigger.getBoundingClientRect(), k = g.getBoundingClientRect(), $ = l.valueNode.getBoundingClientRect(), G = C.getBoundingClientRect();
        if (l.dir !== "rtl") {
          const P = G.left - k.left, R = $.left - P, te = E.left - R, oe = E.width + te, Se = Math.max(oe, k.width), be = window.innerWidth - j, we = Ze(R, [j, be - Se]);
          c.style.minWidth = `${oe}px`, c.style.left = `${we}px`;
        } else {
          const P = k.right - G.right, R = window.innerWidth - $.right - P, te = window.innerWidth - E.right - R, oe = E.width + te, Se = Math.max(oe, k.width), be = window.innerWidth - j, we = Ze(R, [j, be - Se]);
          c.style.minWidth = `${oe}px`, c.style.right = `${we}px`;
        }
        const F = p(), O = window.innerHeight - j * 2, L = S.scrollHeight, B = window.getComputedStyle(g), U = parseInt(B.borderTopWidth, 10), K = parseInt(B.paddingTop, 10), X = parseInt(B.borderBottomWidth, 10), Z = parseInt(B.paddingBottom, 10), W = U + K + L + Z + X, ue = Math.min(x.offsetHeight * 5, W), z = window.getComputedStyle(S), se = parseInt(z.paddingTop, 10), de = parseInt(z.paddingBottom, 10), J = E.top + E.height / 2 - j, ce = O - J, ee = x.offsetHeight / 2, b = x.offsetTop + ee, y = U + K + b, D = W - y;
        if (y <= J) {
          const P = x === F[F.length - 1].ref.current;
          c.style.bottom = "0px";
          const R = g.clientHeight - S.offsetTop - S.offsetHeight, te = Math.max(
            ce,
            ee + // viewport might have padding bottom, include it to avoid a scrollable viewport
            (P ? de : 0) + R + X
          ), oe = y + te;
          c.style.height = `${oe}px`;
        } else {
          const P = x === F[0].ref.current;
          c.style.top = "0px";
          const te = Math.max(
            J,
            U + S.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
            (P ? se : 0) + ee
          ) + D;
          c.style.height = `${te}px`, S.scrollTop = y - J + S.offsetTop;
        }
        c.style.margin = `${j}px 0`, c.style.minHeight = `${ue}px`, c.style.maxHeight = `${O}px`, t?.(), requestAnimationFrame(() => u.current = !0);
      }
    }, [
      p,
      l.trigger,
      l.valueNode,
      c,
      g,
      S,
      x,
      C,
      l.dir,
      t
    ]);
    H(() => w(), [w]);
    const [A, V] = r.useState();
    H(() => {
      g && V(window.getComputedStyle(g).zIndex);
    }, [g]);
    const M = r.useCallback(
      (E) => {
        E && m.current === !0 && (w(), h?.(), m.current = !1);
      },
      [w, h]
    );
    return /* @__PURE__ */ d(
      _o,
      {
        scope: e,
        contentWrapper: c,
        shouldExpandOnScrollRef: u,
        onScrollButtonChange: M,
        children: /* @__PURE__ */ d(
          "div",
          {
            ref: a,
            style: {
              display: "flex",
              flexDirection: "column",
              position: "fixed",
              zIndex: A
            },
            children: /* @__PURE__ */ d(
              N.div,
              {
                ...o,
                ref: v,
                style: {
                  // When we get the height of the content, it includes borders. If we were to set
                  // the height without having `boxSizing: 'border-box'` it would be too big.
                  boxSizing: "border-box",
                  // We need to ensure the content doesn't get taller than the wrapper
                  maxHeight: "100%",
                  ...o.style
                }
              }
            )
          }
        )
      }
    );
  }
);
St.displayName = No;
const Ao = "SelectPopperPosition", Te = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, align: t = "start", collisionPadding: o = j, ...l } = n, i = ve(e);
    return /* @__PURE__ */ d(
      le.Content,
      {
        ...i,
        ...l,
        ref: s,
        align: t,
        collisionPadding: o,
        style: {
          // Ensure border-box for floating-ui calculations
          boxSizing: "border-box",
          ...l.style,
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
Te.displayName = Ao;
const [_o, He] = ae(
  re,
  {}
), Ve = "SelectViewport", $e = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, ...t } = n, o = Q(Ve, e), l = He(Ve, e), i = _(s, o.onViewportChange), c = r.useRef(0);
    return /* @__PURE__ */ Ne(Ae, { children: [
      /* @__PURE__ */ d(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          }
        }
      ),
      /* @__PURE__ */ d(Ce.Slot, { scope: e, children: /* @__PURE__ */ d(
        N.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...t,
          ref: i,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            overflow: "auto",
            ...t.style
          },
          onScroll: T(t.onScroll, (a) => {
            const g = a.currentTarget, { contentWrapper: f, shouldExpandOnScrollRef: v } = l;
            if (v?.current && f) {
              const p = Math.abs(c.current - g.scrollTop);
              if (p > 0) {
                const u = window.innerHeight - j * 2, m = parseFloat(f.style.minHeight), S = parseFloat(f.style.height), x = Math.max(m, S);
                if (x < u) {
                  const C = x + p, h = Math.min(u, C), w = C - h;
                  f.style.height = `${h}px`, f.style.bottom === "0px" && (g.scrollTop = w > 0 ? w : 0, f.style.justifyContent = "flex-end");
                }
              }
            }
            c.current = g.scrollTop;
          })
        }
      ) })
    ] });
  }
);
$e.displayName = Ve;
const bt = "SelectGroup", [Mo, Oo] = ae(bt), Ue = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, ...t } = n, o = ne();
    return /* @__PURE__ */ d(Mo, { scope: e, id: o, children: /* @__PURE__ */ d(N.div, { role: "group", "aria-labelledby": o, ...t, ref: s }) });
  }
);
Ue.displayName = bt;
const wt = "SelectLabel", Ke = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, ...t } = n, o = Oo(wt, e);
    return /* @__PURE__ */ d(N.div, { id: o.id, ...t, ref: s });
  }
);
Ke.displayName = wt;
const ge = "SelectItem", [Do, yt] = ae(ge), We = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, value: t, disabled: o = !1, textValue: l, ...i } = n, c = q(ge, e), a = Q(ge, e), g = typeof t == "string" ? Array.isArray(c.value) ? c.value.includes(t) : c.value === t : t.every((h) => c.value?.includes(h)), f = Array.isArray(c.value) && Array.isArray(t) && t.some((h) => c.value?.includes(h)), [v, p] = r.useState(l ?? ""), [u, m] = r.useState(!1), S = _(
      s,
      (h) => a.itemRefCallback?.(h, t, o)
    ), x = ne(), C = () => {
      if (!o) {
        let h = c.multi && typeof t == "string" ? [t] : t;
        f && !g ? c.onValueChange(h) : Array.isArray(c.value) && (h = Pt(t, c.value)), c.onValueChange(h), c.multi || c.onOpenChange(!1);
      }
    };
    if (!c.multi && Array.isArray(t))
      throw new Error("You can only pass an array of values in multi selects");
    return /* @__PURE__ */ d(
      Do,
      {
        scope: e,
        value: t,
        disabled: o,
        textId: x,
        isSelected: g,
        isIntermediate: f,
        onItemTextChange: r.useCallback((h) => {
          p((w) => w || (h?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ d(Ce.ItemSlot, { scope: e, value: t, disabled: o, textValue: v, children: /* @__PURE__ */ d(
          N.div,
          {
            role: "option",
            "aria-labelledby": x,
            "data-highlighted": u ? "" : void 0,
            "aria-selected": c.multi ? void 0 : g && u,
            "aria-checked": c.multi ? g : void 0,
            "data-state": g ? "checked" : "unchecked",
            "aria-disabled": o || void 0,
            "data-disabled": o ? "" : void 0,
            tabIndex: o ? void 0 : -1,
            ...i,
            ref: S,
            onFocus: T(i.onFocus, () => m(!0)),
            onBlur: T(i.onBlur, () => m(!1)),
            onPointerUp: T(i.onPointerUp, C),
            onPointerMove: T(i.onPointerMove, (h) => {
              o ? a.onItemLeave?.() : h.currentTarget.focus({ preventScroll: !0 });
            }),
            onPointerLeave: T(i.onPointerLeave, (h) => {
              h.currentTarget === document.activeElement && a.onItemLeave?.();
            }),
            onKeyDown: T(i.onKeyDown, (h) => {
              a.searchRef?.current !== "" && h.key === " " || (bo.includes(h.key) && C(), h.key === " " && h.preventDefault());
            })
          }
        ) })
      }
    );
  }
);
We.displayName = ge;
const fe = "SelectItemText", ze = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, className: t, style: o, ...l } = n, i = q(fe, e), c = Q(fe, e), a = yt(fe, e), g = Vo(fe, e), [f, v] = r.useState(null), p = _(
      s,
      (C) => v(C),
      a.onItemTextChange,
      (C) => c.itemTextRefCallback?.(C, a.value, a.disabled)
    ), u = f?.textContent, m = r.useMemo(
      () => /* @__PURE__ */ d(
        "option",
        {
          value: a.value,
          disabled: a.disabled,
          children: u
        },
        Array.isArray(a.value) ? a.value.join(";") : a.value
      ),
      [a.disabled, a.value, u]
    ), { onNativeOptionAdd: S, onNativeOptionRemove: x } = g;
    return H(() => (S(m), () => x(m)), [S, x, m]), /* @__PURE__ */ Ne(Ae, { children: [
      /* @__PURE__ */ d(N.span, { id: a.textId, ...l, ref: p }),
      a.isSelected && i.valueNode && !i.valueNodeHasChildren ? _e.createPortal(l.children, i.valueNode) : null
    ] });
  }
);
ze.displayName = fe;
const It = "SelectItemIndicator", Ge = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, children: t, ...o } = n, l = yt(It, e);
    return typeof t == "function" ? /* @__PURE__ */ d(N.span, { "aria-hidden": !0, ...o, ref: s, children: t({
      isSelected: l.isSelected,
      isIntermediate: l.isIntermediate
    }) }) : l.isSelected ? /* @__PURE__ */ d(N.span, { "aria-hidden": !0, ...o, ref: s, children: t }) : null;
  }
);
Ge.displayName = It;
const Ee = "SelectScrollUpButton", je = r.forwardRef(
  (n, s) => {
    const e = Q(Ee, n.__scopeSelect), t = He(Ee, n.__scopeSelect), [o, l] = r.useState(!1), i = _(s, t.onScrollButtonChange);
    return H(() => {
      if (e.viewport && e.isPositioned) {
        const c = e.viewport, a = () => {
          const g = c.scrollTop > 0;
          l(g);
        };
        return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
      }
    }, [e.viewport, e.isPositioned]), o ? /* @__PURE__ */ d(
      Tt,
      {
        ...n,
        ref: i,
        onAutoScroll: () => {
          const { viewport: c, selectedItem: a } = e;
          c && a && (c.scrollTop -= a.offsetHeight);
        }
      }
    ) : null;
  }
);
je.displayName = Ee;
const Pe = "SelectScrollDownButton", Ye = r.forwardRef(
  (n, s) => {
    const e = Q(Pe, n.__scopeSelect), t = He(Pe, n.__scopeSelect), [o, l] = r.useState(!1), i = _(s, t.onScrollButtonChange);
    return H(() => {
      if (e.viewport && e.isPositioned) {
        const c = e.viewport, a = () => {
          const g = c.scrollHeight - c.clientHeight, f = Math.ceil(c.scrollTop) < g;
          l(f);
        };
        return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
      }
    }, [e.viewport, e.isPositioned]), o ? /* @__PURE__ */ d(
      Tt,
      {
        ...n,
        ref: i,
        onAutoScroll: () => {
          const { viewport: c, selectedItem: a } = e;
          c && a && (c.scrollTop += a.offsetHeight);
        }
      }
    ) : null;
  }
);
Ye.displayName = Pe;
const Tt = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, onAutoScroll: t, ...o } = n, l = Q("SelectScrollButton", e), i = r.useRef(null), c = he(e), a = r.useCallback(() => {
      i.current !== null && (window.clearInterval(i.current), i.current = null);
    }, []);
    return r.useEffect(() => () => a(), [a]), H(() => {
      c().find((f) => f.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
    }, [c]), /* @__PURE__ */ d(
      N.div,
      {
        "aria-hidden": !0,
        ...o,
        ref: s,
        style: { flexShrink: 0, ...o.style },
        onPointerMove: T(o.onPointerMove, () => {
          l.onItemLeave?.(), i.current === null && (i.current = window.setInterval(t, 50));
        }),
        onPointerLeave: T(o.onPointerLeave, () => {
          a();
        })
      }
    );
  }
), ko = "SelectSeparator", qe = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, ...t } = n;
    return /* @__PURE__ */ d(N.div, { "aria-hidden": !0, ...t, ref: s });
  }
);
qe.displayName = ko;
const Re = "SelectArrow", Xe = r.forwardRef(
  (n, s) => {
    const { __scopeSelect: e, ...t } = n, o = ve(e), l = q(Re, e), i = Q(Re, e);
    return l.open && i.position === "popper" ? /* @__PURE__ */ d(le.Arrow, { ...o, ...t, ref: s }) : null;
  }
);
Xe.displayName = Re;
const Fo = "BubbleSelect", Lo = r.forwardRef(
  (n, s) => {
    const { value: e, ...t } = n, o = r.useRef(null), l = _(s, o), i = _t(e), c = q(Fo, void 0);
    r.useEffect(() => {
      const g = o.current, f = window.HTMLSelectElement.prototype, p = Object.getOwnPropertyDescriptor(f, "value").set;
      if (i !== e && p) {
        const u = new Event("change", { bubbles: !0 });
        p.call(g, e), g.dispatchEvent(u);
      }
    }, [i, e]);
    let a = e;
    return c.multi && !Array.isArray(e) && (a = []), /* @__PURE__ */ d(Mt, { asChild: !0, children: /* @__PURE__ */ d(
      "select",
      {
        ...t,
        multiple: c.multi ? !0 : void 0,
        ref: l,
        defaultValue: a
      }
    ) });
  }
);
Lo.displayName = "BubbleSelect";
function Vt(n) {
  const s = At(n), e = r.useRef(""), t = r.useRef(0), o = r.useCallback(
    (i) => {
      const c = e.current + i;
      s(c), function a(g) {
        e.current = g, window.clearTimeout(t.current), g !== "" && (t.current = window.setTimeout(() => a(""), 1e3));
      }(c);
    },
    [s]
  ), l = r.useCallback(() => {
    e.current = "", window.clearTimeout(t.current);
  }, []);
  return r.useEffect(() => () => window.clearTimeout(t.current), []), [e, o, l];
}
function Et(n, s, e) {
  const o = s.length > 1 && Array.from(s).every((g) => g === s[0]) ? s[0] : s, l = e ? n.indexOf(e) : -1;
  let i = Bo(n, Math.max(l, 0));
  o.length === 1 && (i = i.filter((g) => g !== e));
  const a = i.find((g) => g.textValue.toLowerCase().startsWith(o.toLowerCase()));
  return a !== e ? a : void 0;
}
function Bo(n, s) {
  return n.map((e, t) => n[(s + t) % n.length]);
}
const Pt = (n, s = []) => {
  if (Array.isArray(n))
    return n.reduce((t, o) => Pt(o, t), s);
  const e = s.indexOf(n);
  return e === -1 ? [...s, n] : [...s.slice(0, e), ...s.slice(e + 1)];
}, Ho = Oe, $o = De, Uo = ke, Ko = Fe, Wo = Le, zo = Be, Go = $e, jo = Ue, Yo = Ke, qo = We, Xo = ze, Zo = Ge, Jo = je, Qo = Ye, en = qe, tn = Xe, Vn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arrow: tn,
  Content: zo,
  Group: jo,
  Icon: Ko,
  Item: qo,
  ItemIndicator: Zo,
  ItemText: Xo,
  Label: Yo,
  Portal: Wo,
  Root: Ho,
  ScrollDownButton: Qo,
  ScrollUpButton: Jo,
  Select: Oe,
  SelectArrow: Xe,
  SelectContent: Be,
  SelectGroup: Ue,
  SelectIcon: Fe,
  SelectItem: We,
  SelectItemIndicator: Ge,
  SelectItemText: ze,
  SelectLabel: Ke,
  SelectPortal: Le,
  SelectScrollDownButton: Ye,
  SelectScrollUpButton: je,
  SelectSeparator: qe,
  SelectTrigger: De,
  SelectValue: ke,
  SelectViewport: $e,
  Separator: en,
  Trigger: $o,
  Value: Uo,
  Viewport: Go,
  createSelectScope: yo
}, Symbol.toStringTag, { value: "Module" }));
export {
  Tn as Combobox,
  Vn as Select,
  Rn as useCallbackRef
};
